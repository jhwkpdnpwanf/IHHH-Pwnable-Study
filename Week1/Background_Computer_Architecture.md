# 컴퓨터 구조

### **컴퓨터 구조(Computer Architecture)**

- 컴퓨터가 효율적으로 작동할 수 있도록 **하드웨어 및 소프트웨어의 기능**을 고안하고, 이들을 **구성하는 방법**을 말한다.
<br>

**컴퓨터 구조의 세부 분야** 

```markdown
- 기능 구조의 설계
    ✔️ 폰 노이만 구조
    - 하버드 구조
    - 수정된 하버드 구조
  
- 명령어 집합구조
    ✔️ x86, x86-64
    - ARM
    - MIPS
    - AVR
    
- 마이크로 아키텍처
    - 캐시 설계
    - 파이프라이닝
    - 슈퍼 스칼라
    - 분기 예측
    - 비순차적 명령어 처리
    
- 하드웨어 및 컴퓨팅 방법론
    - 직접 메모리 접근
```

- **기능 구조의 설계** :  프로그램 실행 방식
- **명령어 집합 구조** : CPU 명령어 체계
- **마이크로 아키텍처** : CPU 내부 설계
- **하드웨어 및 컴퓨팅 방법론 :** 하드웨어 및 입출력 시스템

👉 **폰 노이만 구조**와 **x86-64 아키텍처**에 대해 다뤄볼 살펴볼 예정이다.

<br>

**

<br>

### 폰 노이만 구조

- **연산, 제어, 저장** 세가지 핵심 기능이 존재하는 컴퓨터 설계 모델이다.



1. **CPU (중앙처리장치) →** *연산&제어*
**-  ALU**  :   연산 수행
-  **Register**  :   데이터 임시 저장
-  **Cache**  :   자주 사용하는 데이터를 빠르게 불러오기 위한 저장 공간
2. **MEMORY →** *저장*
-  프로그램과 데이터를 동일한 메모리에 저장하는 공간
-  CPU가 데이터를 읽고 쓰는 작업을 수행
3. **BUS
-** 장치간에 데이터나 제어 신호를 교환할 수 있게 해주는 전자통로
   
<br>

**

<br>

# 세그먼트

- **리눅스 메모리 구조** : 프로세스의 메모리를 크게 5가지로 구분한 것.
    - 코드 세그먼트
    - 데이터 세그먼트
    - BSS 세그먼트
    - 힙 세그먼트
    - 스택 세그먼트  

<br>
*

### 코드 세그먼트

- 실행 가능한 기계 코드가 위치하는 영역
- **텍스트 세그먼트**라고도 불림
    - **부여 권한** : 읽기, 쓰기


**예시**

`int main() {return 31337}` →  `554889e5b8697a00005dc3` 기계 코드로 변환됨.

- 이 기계 코드가 **코드 세그먼트**에 위치하게 됨


<br>
*


### 데이터 세그먼트

- 컴파일 시점에 정해진 **전역 변수 및 전역 상수**들이 위치함.
    - **부여 권한** : 읽기, (쓰기)
        - **쓰기 권한**에 따라 세그먼트가 **다시 분류**됨.
            - **data 세그먼트**
            - **rodata(read-only data) 세그먼트**



**예시**

```c
int data_num = 31337;                       // data
char data_rwstr[] = "writable_data";        // data
const char data_rostr[] = "readonly_data";  // rodata
char *str_ptr = "readonly";  // str_ptr은 data, 문자열은 rodata

int main() { ... }
```

- `str_ptr`은 `readonly`라는 문자열을 가리키고 있는데, 
이 문자열은 **상수 문자열**로 취급되어 ***rodata* 에 위치**하며, 이를 가리키는 `str_ptr`은 **전역 변수**로서 ***data*에 위치**한다.

<br>
*

### BSS 세그먼트

- **컴파일 시점에 값이 정해지지 않은 전역변수**가 위치하는 메모리 영역.
- **선언만 하고 초기화하지 않은** **전역변수**
- 이 세그먼트의 메모리 영역은 프로그램이 시작될 때, 모두 0으로 값이 초기화됨
    - **부여 권한** : 읽기, 쓰기

**예시**

```c
int bss_data;

int main() {
  printf("%d\n", bss_data);  // 0
  return 0;
}
```

- **초기화되지 않은 전역 변수**인 `bss_data`가 **BSS 세그먼트**에 위치

<br>
*

### 스택 세그먼트

- 프로세스의 **스택**이 위치하는 영역
- **함수의 인자**나 **지역 변수**와 같은 **임시 변수**들이 실행 중에 여기에 저장됨.
    - **부여 권한** : 읽기, 쓰기

- 스택 세그먼트는 **스택 프레임(Stack Frame)** 이라는 단위로 사용
    - **스택 프레임**은 함수가 호출될 때 생성되고, 반환 될 때 해제

**예시**

```c
void func() {
  int choice = 0;

  scanf("%d", &choice);

  if (choice)
    call_true();
  else
    call_false();

  return 0;
}
```

- 사용자의 선택에 따라 **호출되는 함수가 다름**
    
    **→** *미리 계산이 일반적으로 불가능*
    
    → 그래서 운영체제는 프로세스를 시작할 때 **작은 크기의 스택 세그먼트를**
         **먼저 할당**해주고, **부족해 질 때마다 이를 확장**
    
    - *스택은 낮은 주소로 확장됨*

<br>
*

### 힙 세그먼트

- **힙 데이터가 위치**하는 세그먼트.
- **동적으로 할당**될 수 있으며, 리눅스에서는 스택 세그먼트와 **반대 방향**으로 자람.
- C언어에서 `malloc()`, `calloc()` 등을 호출해서 할당 받는 메모리가 이 세그먼트에 위치
    - **부여 권한** : 읽기, 쓰기

**예시**

```c
int main() {
  int *heap_data_ptr =
      malloc(sizeof(*heap_data_ptr));  // 동적 할당한 힙 영역의 주소를 가리킴
  *heap_data_ptr = 31337;              // 힙 영역에 값을 씀
  printf("%d\n", *heap_data_ptr);  // 힙 영역의 값을 사용함
  return 0;
}
```

- `heap_data_ptr`에 `malloc()`으로 **동적 할당한 영역의 주소를 대입**하고, 
이 영역에 값을 쓴다.
- `heap_data_ptr`은 지역변수이므로 스택에 위치하며, `malloc`으로 **할당 받은 힙 세그먼트의 주소**를 가리킴.

**
